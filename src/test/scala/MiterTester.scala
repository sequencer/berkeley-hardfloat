package hardfloat.test

import java.io._

import chisel3.RawModule
import chisel3.stage.ChiselGeneratorAnnotation
import firrtl.AnnotationSeq
import firrtl.options.TargetDirAnnotation
import firrtl.stage.{FirrtlCircuitAnnotation, FirrtlFileAnnotation, FirrtlStage, OutputFileAnnotation}
import scala.sys.process.{Process, ProcessLogger}
import java.nio.file._

/** [[MiterTester]] will construct a Miter circuit with yosys to do LEC check. */
trait MiterTester extends HardfloatTester {
  private def getTopName(annotations: AnnotationSeq) = annotations.collectFirst {
    case FirrtlCircuitAnnotation(c) => c.main
  }.get

  def check(ret: Int): Unit = ret should equal(0)

  def generate(referenceFir: String, module: () => RawModule): Int = {
    val testDir: File = createTestDirectory(this.getClass.getSimpleName + s"_$referenceFir")
    val testDirAbsolutePath: String = testDir.toPath.toAbsolutePath.toString

    (new chisel3.stage.ChiselStage).execute(
      Array("-E", "chirrtl"),
      Seq(
        TargetDirAnnotation(testDirAbsolutePath),
        ChiselGeneratorAnnotation(module),
        OutputFileAnnotation(referenceFir)
      )
    )
    java.nio.file.Files.copy(
      Paths.get(testDirAbsolutePath + File.separator + s"$referenceFir.fir"),
      Paths.get("src" + File.separator + "test" + File.separator + "resources" + File.separator + "reference" + File.separator + s"$referenceFir.fir"),
      StandardCopyOption.REPLACE_EXISTING
    )
    0
  }

  /** Run a Miter equivalence check.
    *
    * @param module          function to generate DUT.
    * @param referenceModule reference module filename in firrtl, should exist in `reference` directory.
    */
  def test(referenceFir: String, module: () => RawModule, timesteps: Int = 1): Int = {
    /** generated test directory. */
    val testDir: File = createTestDirectory(this.getClass.getSimpleName + s"_$referenceFir")
    val testDirAbsolutePath: String = testDir.toPath.toAbsolutePath.toString

    /** verilog string generated by [[module]]. */
    val testModuleAnnotation = (new chisel3.stage.ChiselStage).execute(
      Array("-X", "verilog"),
      Seq(
        TargetDirAnnotation(testDirAbsolutePath),
        ChiselGeneratorAnnotation(module),
        OutputFileAnnotation("module")
      )
    )

    /** verilog string generated by [[referenceFir]]. */
    val referenceModuleAnnotation = (new FirrtlStage).execute(
      Array("-X", "verilog"),
      Seq(
        TargetDirAnnotation(testDirAbsolutePath),
        FirrtlFileAnnotation(getClass.getResource(s"/reference/$referenceFir.fir").getPath),
        OutputFileAnnotation("reference")
      )
    )

    val moduleFile = testDir.toPath.toAbsolutePath.toString + File.separator + "module.v"
    val referenceFile = testDir.toPath.toAbsolutePath.toString + File.separator + "reference.v"
    val scriptFile = testDir.toPath.toAbsolutePath.toString + File.separator + "script.tcl"
    val moduleTopName = getTopName(testModuleAnnotation)
    val referenceTopName = getTopName(referenceModuleAnnotation)
    val scriptWriter = new PrintWriter(scriptFile)

    scriptWriter.write(
      s"""read_verilog $moduleFile
         |prep -flatten -top $moduleTopName; proc; opt; memory
         |design -stash custom
         |read_verilog $referenceFile
         |prep -flatten -top $referenceTopName; proc; opt; memory
         |design -stash reference
         |design -copy-from custom -as custom $moduleTopName
         |design -copy-from reference -as reference $referenceTopName
         |equiv_make custom reference equiv
         |hierarchy -top equiv
         |prep -flatten -top equiv
         |clean -purge
         |equiv_simple -seq $timesteps
         |equiv_induct -seq $timesteps
         |equiv_status -assert
         """.stripMargin
    )
    scriptWriter.close()

    Process(s"yosys -s $scriptFile") ! ProcessLogger(logger.warn(_), logger.error(_))
  }

}
